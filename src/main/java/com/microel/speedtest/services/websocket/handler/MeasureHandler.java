package com.microel.speedtest.services.websocket.handler;

import java.io.IOException;
import java.net.InetAddress;
import java.util.ArrayList;
import java.util.Arrays;
import java.util.List;
import java.util.UUID;
import java.util.stream.Collectors;

import org.jetbrains.annotations.NotNull;
import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.scheduling.annotation.Scheduled;
import org.springframework.stereotype.Component;
import org.springframework.web.socket.*;

import com.fasterxml.jackson.core.JsonProcessingException;
import com.fasterxml.jackson.core.exc.StreamReadException;
import com.fasterxml.jackson.databind.DatabindException;
import com.fasterxml.jackson.databind.ObjectMapper;
import com.microel.speedtest.controllers.measure.MeasureController;
import com.microel.speedtest.services.websocket.interfaces.IDisconnectHandler;
import com.microel.speedtest.services.websocket.interfaces.StandardSocketHandler;
import com.microel.speedtest.services.websocket.transport.MeasureActionMessage;

import lombok.extern.slf4j.Slf4j;

@Slf4j
@Component
public class MeasureHandler extends StandardSocketHandler implements WebSocketHandler {

    private final MeasureController measureController;

    public MeasureHandler(MeasureController measureController) {
        this.measureController = measureController;
    }

    @Scheduled(fixedRate = 2500)
    private void heartBeat(){
        sessions.keySet().forEach(session -> {
            try {
                session.sendMessage(new PingMessage());
            } catch (IOException e) {
                log.warn("Ping not sent {}", session.getId());
            }
        });
    }

    @Override
    public void afterConnectionEstablished(WebSocketSession session) throws Exception {
        log.info("Connection established: {} {}", session.getId(), getDeviceId(session));
        sessions.put(session, getDeviceId(session));
        measureController.handleConnect(session);
    }

    @Override
    public void handleMessage(@NotNull WebSocketSession session, @NotNull WebSocketMessage<?> message) throws Exception {
        if(message instanceof PongMessage){
            return;
        }
        if (!bufferingMessage(message))
            return;
        // Getting measure action message from payload
        ObjectMapper mapper = new ObjectMapper();
        // Wrap in try/catch to avoid exception when message is not a valid json string
        try {
            MeasureActionMessage measureActionMessage = mapper.readValue(getBufferedMessage(),
                    MeasureActionMessage.class);
            MeasureActionMessage response = measureController.handleActionMessage(measureActionMessage, session);
            if (response != null) {
                session.sendMessage(new TextMessage(response.toString()));
            }
            // Catch each exception generated by mapper.readValue()
        } catch (StreamReadException e) {
            log.error("Сообщение не является валидным JSON объектом: {}", message.getPayload().toString());
        } catch (DatabindException e) {
            log.error("Получен объект не соответствующего типа: {}", e.getMessage());
        } catch (JsonProcessingException e) {
            log.error("Ошибка преобразования JSON объекта в объект Java: {}", e.getMessage());
        }
    }

    @Override
    public void handleTransportError(WebSocketSession session, Throwable exception) throws Exception {
        log.error("Transport error: {} {}", session.getId(), exception.getMessage());
    }

    @Override
    public void afterConnectionClosed(WebSocketSession session, CloseStatus closeStatus) throws Exception {
        log.info("Connection closed: {} {}", session.getId(), closeStatus.getReason());
        measureController.handleDisconnect(session);
        // Remove session from map and emit disconnect event
        sessions.remove(session);
        IDisconnectHandler handler = disconnectHandlers.remove(session);
        if (handler != null) {
            handler.handle(getDeviceId(session));
        }
    }

    @Override
    public boolean supportsPartialMessages() {
        return true;
    }

    public static String getRemoteIp(WebSocketSession session){
        final byte[] remoteAddress =session.getRemoteAddress().getAddress().getAddress();
        final List<String> convertedAddress = new ArrayList<>();
        for (byte b : remoteAddress) {
            int integer = b & 0xff;
            String toString = Integer.toString(integer);
            convertedAddress.add(toString);
        }
        final String stringifyAddress = String.join(".", convertedAddress);
        return stringifyAddress;
    }

}
